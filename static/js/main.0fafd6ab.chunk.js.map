{"version":3,"sources":["features/square/squareSlice.js","features/square/helper.js","features/square/Square.js","components/Board.js","App.js","features/counter/counterSlice.js","app/store.js","serviceWorker.js","index.js"],"names":["initialState","i","j","row","Math","floor","col","String","squareSlice","createSlice","name","board","highlight","active","isSolvable","reducers","setSquare","state","action","value","Number","payload","square","setSolution","setSolvable","resetPuzzle","highlightNeighbors","neighbors","actions","neighborsOf","box","push","boxRow","boxCol","Set","filter","neighbor","Square","props","dispatch","useDispatch","useSelector","isActive","isHighlighted","includes","handleFocus","e","classes","useEffect","document","getElementById","focus","tabIndex","className","id","onChange","target","onFocus","onClick","onKeyDown","keyCode","preventDefault","newSquare","Board","Box","squares","key","App","useState","isSolved","setSolved","result","solvable","squareKeys","Object","keys","entries","forEach","possVals","neighborVal","num","length","findSolution","currentSquares","emptyKeys","some","console","count","emptyKey","sort","squareA","squareB","alteredSquares","tryVal","shift","emptyNeighbor","index","indexOf","splice","solvableSquare","find","emptySquare","solution","getSortSolution","disabled","counterSlice","increment","decrement","incrementByAmount","configureStore","reducer","counter","counterReducer","squareReducer","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","store","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0fafd6ab.chunk.js","sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\r\n\r\nlet initialState = {};\r\n\r\nfor (let i = 0; i < 9; i++) {\r\n    for (let j = 0; j < 9; j++) {\r\n        let row = (Math.floor(i/3)*3 + 1) + Math.floor(j/3);\r\n        let col = (((i % 3) * 3) + 1) + (j % 3)\r\n        initialState[String(row)+String(col)] = ''\r\n    }\r\n}\r\n\r\nexport const squareSlice = createSlice({\r\n    name: 'square',\r\n    initialState: {\r\n        board: initialState,\r\n        highlight: [],\r\n        active: '55',\r\n        isSolvable: true\r\n    },\r\n    reducers: {\r\n        setSquare: (state, action) => {\r\n            // console.log(action.payload);\r\n            let value;\r\n            if (Number(action.payload.value)) {\r\n                value = Number(action.payload.value)\r\n            } else {\r\n                value = ''\r\n            }\r\n            if (value > 9) {\r\n                value = Number(String(value)[1])\r\n            }\r\n            state.board[action.payload.square] = value;\r\n        },\r\n        setSolution: (state, action) => {\r\n            //console.log(action.payload);\r\n            state.board = action.payload;\r\n        },\r\n        setSolvable: (state, action) => {\r\n            state.isSolvable = action.payload;\r\n        },\r\n        resetPuzzle: (state) => {\r\n            state.board = initialState;            \r\n        },\r\n        highlightNeighbors: (state, action) => {\r\n            state.active = action.payload.active;\r\n            state.highlight = action.payload.neighbors;\r\n        }\r\n    }\r\n})\r\n\r\nexport const { setSquare, setSolution, setSolvable, resetPuzzle, highlightNeighbors } = squareSlice.actions;\r\n\r\nexport default squareSlice.reducer;","//import { useEffect } from 'react';\r\n//import { useSelector } from 'react-redux';\r\nimport { setSolution, setSolvable } from './squareSlice';\r\n\r\nexport const neighborsOf = square => {\r\n    let neighbors = []\r\n    let row = Number(square[0]);\r\n    let col = Number(square[1]);\r\n    let box = Math.floor((row-1)/3)*3 + 1 + Math.floor((col-1)/3)\r\n    for (let i = 0; i<9; i++) {\r\n        //row\r\n        neighbors.push(String(row) + String(i+1));\r\n        \r\n        //col\r\n        neighbors.push(String(i+1) + String(col));\r\n\r\n        //box\r\n        let boxRow = (Math.floor((box-1)/3)*3 + 1) + Math.floor(i/3);\r\n        let boxCol = (((box-1) % 3)*3) + 1 + (i % 3);\r\n        neighbors.push(String(boxRow)+String(boxCol))\r\n    }\r\n    //console.log([...new Set(neighbors.filter(neighbor => neighbor!==square))]); \r\n    return ([...new Set(neighbors.filter(neighbor => neighbor!==square))]); \r\n}\r\n\r\nexport const getSolution = (squares) => {\r\n    squares = {...squares};\r\n    let solvable = true;\r\n    const getPossibleValuesInSolution = (square, solvedSquares) => {\r\n        let possVals = [1,2,3,4,5,6,7,8,9]\r\n        neighborsOf(square).forEach(neighbor => {\r\n            let neighborVal = solvedSquares[neighbor];\r\n            if (neighborVal && possVals.includes(neighborVal)) {\r\n                possVals = possVals.filter(num => num !==neighborVal)\r\n            }\r\n        })\r\n        return possVals;\r\n    }\r\n    \r\n    const fitsWithNeighbors = (square, newValue) => {\r\n        return !neighborsOf(square).some(neighbor => squares[neighbor] === newValue)\r\n    }\r\n    \r\n    let filled = Object.entries(squares).filter(([square,value]) => !!value);\r\n    if (filled.filter(([square,value]) => !fitsWithNeighbors(square,value)).length !==0) {\r\n        setSolvable(false); //not solvable\r\n        solvable = false;\r\n    } else {\r\n        setSolution(squares);\r\n    };\r\n    \r\n    //for each empty square\r\n    // let empties = Object.entries(squares).filter(([square,value]) => !value).map(([square,value]) => square); //list of string corresponding to empty squares\r\n    \r\n    const findSolution = solvedSquares => {\r\n        let index = Object.entries(solvedSquares).findIndex(([square,value]) => !value)\r\n        //if theres no empty, there's nothing to evaluate. The solution is good\r\n        if (index === -1) {\r\n            let isSolved = true;\r\n            let isSolvable = true;\r\n            return ([solvedSquares, isSolved, isSolvable]); //solvedsquares, isSolved, isSolvable\r\n        }\r\n\r\n        let empty = Object.entries(solvedSquares)[index][0];\r\n        let isSolved = false;\r\n        let isSolvable = true;\r\n        // console.log(`Solving for ${empty}`);\r\n\r\n        //if the puzzle isnt impossible, and it hasn't been solved yet\r\n        while (isSolvable && !isSolved) {\r\n            //console.log(empty);\r\n            //find all possible options for that box\r\n            let possVals = getPossibleValuesInSolution(empty, solvedSquares);\r\n            // console.log(`${empty}: ${possVals}`)\r\n            //if there are options and the puzzle isnt solved yet\r\n            while ((possVals.length > 0) && !isSolved) {\r\n                //console.log(possVals);\r\n                //try the first possible option for that box\r\n                let tryVal = possVals.shift();\r\n                // console.log(`Trying: ${tryVal} in ${empty}`);\r\n                solvedSquares[empty] = tryVal;\r\n                //find a solution for a set with the first box solved\r\n                [solvedSquares, isSolved, isSolvable] = findSolution(solvedSquares);\r\n                if (!isSolvable) {\r\n                    //emptyList.unshift(empty);\r\n                }\r\n            }\r\n            if (possVals.length === 0 && !isSolved) {\r\n                // console.log(`No available values for ${empty}! Going back to previous.`)\r\n                // console.log(`adding ${empty} back to list`);\r\n                solvedSquares[empty] = '';\r\n                \r\n                isSolvable = false;\r\n                \r\n                // console.log(`Returning, isSolvable=${isSolvable} for ${empty}`)\r\n            }\r\n            console.count('badguess')\r\n            return ([solvedSquares, isSolved, isSolvable]);\r\n        }\r\n    }\r\n    \r\n    if (solvable) {\r\n        let [ a, b, c] = findSolution(squares)//solvedsquares, isSolved, isSolvable\r\n        console.log(b ? 'solved': 'unsolved', c ? 'solvable' : 'unsolvable');\r\n        return b ? a : null;\r\n    } else {\r\n        console.log('unsolvable');\r\n        return null;\r\n    }\r\n    //setSolution(solution);\r\n    //setSolvable(isSolvable);\r\n}\r\n// \r\n// \r\n// \r\n// \r\n// \r\n// \r\n// \r\n// \r\nexport const getSortSolution = (squares) => {\r\n    let solvable = true;\r\n    squares = {...squares};//make a copy\r\n    //squares is of the form {'11':value, '12': value}\r\n    //change squares to {'11': {value: value, possVals: [], neighbors: []}}\r\n    //start with a smart squares object, each square knows who its neighbors are and what possible values it can have.\r\n    let squareKeys = Object.keys(squares);\r\n\r\n    Object.entries(squares).forEach(([square,value]) => {\r\n        squares[square] = {\r\n            value,\r\n            possVals: [],//populated next\r\n            neighbors: neighborsOf(square)\r\n        }\r\n    });\r\n    \r\n    //define all possible values for squares\r\n    squareKeys.forEach(square=> {\r\n        let possVals = [1,2,3,4,5,6,7,8,9];\r\n        let neighbors = squares[square].neighbors;\r\n        neighbors.forEach(neighbor => {\r\n            let neighborVal = squares[neighbor].value;\r\n            if (neighborVal && possVals.includes(neighborVal)) {\r\n                possVals = possVals.filter(num => num !== neighborVal)\r\n            }\r\n        })\r\n        if (possVals.length ===0) {//if theres a square with no possible value the puzzle is unsolvable\r\n            solvable = false\r\n        }\r\n        squares[square].possVals = possVals;\r\n    });\r\n    \r\n    const findSolution = currentSquares => {\r\n        //returns currentSquares if they are good, returns false if they are not\r\n        \r\n        //second time through, the empty keys will not include any squares that were assigned a value\r\n        let emptyKeys = Object.keys(currentSquares).filter(square => !currentSquares[square].value);\r\n        //if there are no empty squares, there's nothing to evaluate. The solution is good\r\n        if (emptyKeys.length===0) {\r\n            // console.log('No empty keys: Solution Verified!')\r\n            return currentSquares; //currentSquares, isSolved, isSolvable\r\n        }\r\n        // console.log(`Solving for: ${emptyKeys}`);\r\n        \r\n        //if any empty square has no possible values, the solution is bad\r\n        if (emptyKeys.some(square => currentSquares[square].possVals.length === 0)) {\r\n            // console.log('Squares exist with no possible values.');\r\n            console.count('badguess')\r\n            return false; //currentSquares, isSolved, isSolvable\r\n        }\r\n        \r\n        //get the first empty square sorted by lowest number of possible values\r\n        //2nd time, fewer empty squares and possible values\r\n        //Creative solution later: \r\n            //sort again by squares with possible values needed in the fewest places on the board\r\n            //(only two squares need a 1 type logic) \r\n            //https://coderwall.com/p/ebqhca/javascript-sort-by-two-fields\r\n            // return a-b || c-d to do a double sort\r\n            // if a and b are equal, it will sort based on c and d\r\n            //need to create values c/d that correspond to the overall entropy of a squares poss values\r\n            // entropy equals value*numSquaresPossible + value*numSquaresPossible\r\n            // lowest entropy is best. entropy sorts by both at same time!\r\n        let emptyKey = emptyKeys.sort((squareA, squareB) => {\r\n            return currentSquares[squareA].possVals.length - currentSquares[squareB].possVals.length\r\n        })[0]\r\n  \r\n        //while the currentsquare has possible values left\r\n        while (currentSquares[emptyKey].possVals.length > 0) {\r\n            // console.log(`Solving for ${emptyKey}`);\r\n            // console.log(`${emptyKey}: ${currentSquares[emptyKey].possVals}`);\r\n            let alteredSquares = [];\r\n            \r\n            //get the first value to try (removing it from this and all deeper possval lists)\r\n            let tryVal = currentSquares[emptyKey].possVals.shift();\r\n            // console.log(`Trying ${tryVal}`);\r\n\r\n            //put the tried value into the currentSquares\r\n            currentSquares[emptyKey].value = tryVal;\r\n\r\n            //remove the tried value from the empty neighbors' possVals\r\n            currentSquares[emptyKey].neighbors.filter(neighbor => !currentSquares[neighbor].value)\r\n            .forEach(emptyNeighbor => {\r\n                //remove the imput value\r\n                let index = currentSquares[emptyNeighbor].possVals.indexOf(tryVal);\r\n                if (index !==-1) {\r\n                    currentSquares[emptyNeighbor].possVals.splice(index, 1);\r\n                }\r\n            })\r\n\r\n            //if there are any squares with only one possible value, set that value and remove from neighbors\r\n            //repeat the process until there are no squares with one value\r\n            while(Object.keys(currentSquares).some(square => !currentSquares[square].value && currentSquares[square].possVals.length ===1)) {\r\n                let solvableSquare = Object.keys(currentSquares).find(square => !currentSquares[square].value && currentSquares[square].possVals.length === 1 )\r\n                let value = currentSquares[solvableSquare].possVals[0];\r\n                // console.log(`Found ${solvableSquare} with only possible value ${value}`);\r\n                currentSquares[solvableSquare].value = value;\r\n                alteredSquares.push(solvableSquare);\r\n                currentSquares[solvableSquare].neighbors.filter(neighbor => !currentSquares[neighbor].value)\r\n                .forEach(emptyNeighbor => {\r\n                    let index = currentSquares[emptyNeighbor].possVals.indexOf(value);\r\n                    if (index !== -1) {\r\n                        currentSquares[emptyNeighbor].possVals.splice(index,1);\r\n                    }\r\n                })\r\n            }\r\n\r\n            //if all empty squares have possible values, the puzzle is solvable and we should go deeper.\r\n            if (!Object.keys(currentSquares).filter(square => !currentSquares[square].value)\r\n            .some(emptySquare => currentSquares[emptySquare].possVals.length ===0)) {\r\n                // console.log(\"Those all worked. Let's go deeper.\");\r\n                let result = findSolution(currentSquares);\r\n                \r\n                if (result) {//if it returned the object, it is our solved object. Send it up.\r\n                    if (result) {\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n            //if this code is running, we didn't get a positive result and return it\r\n            //something with the current configuration is wrong\r\n            // console.log('Found squares with no possible values');\r\n            //if there are more values to be checked for this square\r\n            //reset current empty square\r\n            currentSquares[emptyKey].value = '';\r\n            //reset the squares that were changed\r\n            alteredSquares.forEach(square => {\r\n                currentSquares[square].value = '';\r\n                // console.log(`Resetting ${square}`);\r\n            });\r\n            //reset possVals for all empty squares except the one currently being tested\r\n            emptyKeys.forEach(emptySquare => {\r\n                if (emptyKey === emptySquare) {\r\n                    return;\r\n                }\r\n                let possVals = [1,2,3,4,5,6,7,8,9];\r\n                let neighbors = currentSquares[emptySquare].neighbors;\r\n                neighbors.forEach(neighbor => {\r\n                    let neighborVal = currentSquares[neighbor].value;\r\n                    if (neighborVal && possVals.includes(neighborVal)) {\r\n                        possVals = possVals.filter(num => num !== neighborVal)\r\n                    }\r\n                })\r\n                currentSquares[emptySquare].possVals = possVals;\r\n            });\r\n            if (currentSquares[emptyKey].possVals.length > 0) {\r\n                // console.log(`Trying next value for ${emptyKey}.`)\r\n            } else {//there are no more values to be checked for this square\r\n                //something prior to this was off. return false\r\n                // console.log(`No more possible values for ${emptyKey}. Going back.`);\r\n                console.count('badguess')\r\n\r\n                return false;\r\n            }\r\n        }\r\n        console.count('badguess')\r\n        return false;\r\n    }\r\n    \r\n    if (solvable) {\r\n        let result = findSolution(squares)//solvedsquares, isSolved, isSolvable\r\n        if (!result) {\r\n            // console.log('unsolvable');\r\n            return false;\r\n        } else {\r\n            //return only the values\r\n            let solution = {}\r\n            Object.keys(result).forEach(square => {\r\n                solution[square] = result[square].value;\r\n            });\r\n            return solution;\r\n        }\r\n    } else {\r\n        // console.log('unsolvable');\r\n        return false;\r\n    }\r\n    //setSolution(solution);\r\n    //setSolvable(isSolvable);\r\n}\r\n\r\n\r\n// const solve = () => {\r\n//     let squares = useSelector(state=>state.square);\r\n    \r\n//     //make sure currently filled squares make sense\r\n//     tryToSolve(empties);\r\n//     //check if that square can be set to a value\r\n//     //  if yes and no more squares\r\n//     //      return true;\r\n//     //  if yes and more squares\r\n//     //      check next square\r\n//     //  if no try next value\r\n//     //  if no more values return false\r\n//     if (fitsWithNeighbors(square, 1)) {//check if clicked option works\r\n        \r\n//     } else {\r\n//         return false;\r\n//     }\r\n//     //console.log(empties);\r\n//     return \r\n// }","import React, {useEffect} from 'react';\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport { setSquare, highlightNeighbors } from './squareSlice';\r\nimport { neighborsOf } from './helper';\r\n\r\n\r\nexport const Square = props => {\r\n    const dispatch = useDispatch()\r\n    const square = String(props.row) + String(props.col);\r\n    const neighbors = neighborsOf(square)\r\n    const value = useSelector(state => state.square.board[square]);\r\n    const isActive = useSelector(state => state.square.active === square);\r\n    const isHighlighted = useSelector(state => state.square.highlight.includes(square));\r\n\r\n    if (isActive) {\r\n        dispatch(highlightNeighbors({active: square, neighbors: neighbors}));\r\n    }\r\n\r\n    const handleChange = e => {\r\n        if (Number(e.target.value)) {\r\n            dispatch(setSquare({square: square, value: e.target.value}))\r\n        }\r\n    }\r\n\r\n    const handleFocus = e => {\r\n        dispatch(highlightNeighbors({active: square, neighbors: neighbors}));\r\n    }\r\n\r\n    const handleKeyDown = e => {\r\n        //e.preventDefault();\r\n        let keyCode = e.keyCode;\r\n        //console.log(e.keyCode);   \r\n        if (isActive) {\r\n            if (keyCode > 48 && keyCode <= 57) {\r\n                //dispatch(setSquare({square: square, value: keyCode-48}));\r\n            } else if (keyCode === 8 || keyCode === 46 || keyCode===48 || keyCode ===96) {//backspace and delete and key0 and numpad0\r\n                e.preventDefault();\r\n                dispatch(setSquare({square: square, value: ''}));\r\n\r\n            } else if (keyCode === 37 && square[1]>1) {//left\r\n                let newSquare = square[0] + (Number(square[1]) - 1)\r\n                document.getElementById(`${newSquare}input`).focus();\r\n\r\n            } else if (keyCode === 39 && square[1]<9) {//right\r\n                let newSquare = square[0] + (Number(square[1]) + 1);\r\n                document.getElementById(`${newSquare}input`).focus();\r\n\r\n            } else if (keyCode === 38 && square[0]>1) {//up\r\n                let newSquare = (Number(square[0]) - 1) + square[1];\r\n                document.getElementById(`${newSquare}input`).focus();\r\n                \r\n            } else if (keyCode === 40 && square[0]<9) {//down\r\n                let newSquare = (Number(square[0]) + 1) + square[1];\r\n                document.getElementById(`${newSquare}input`).focus();\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    const classes = 'square ' + (isActive ? 'active ' : '') + (isHighlighted ? 'highlight' : '');\r\n\r\n    useEffect(() => {\r\n        if (isActive) {\r\n            document.getElementById(`${square}input`).focus()\r\n            //ReactDOM.findDOMNode(this.refs[square]).focus()\r\n        }\r\n    }, [isActive, square])\r\n    //make the square red if it is erroneous? using fitsWithNeighbors?\r\n    return (\r\n        <div >\r\n            <input tabIndex={square}  className={classes} id={square+'input'}\r\n            onChange={handleChange} value={value}\r\n            onFocus={handleFocus} onClick={handleFocus} onKeyDown={handleKeyDown}/>\r\n        </div>\r\n    )\r\n}","import React from 'react';\r\nimport { Square } from '../features/square/Square';\r\n\r\n\r\nexport const Board = props => {\r\n    const Box = props => {\r\n        let i = props.box-1;\r\n        let squares = [];\r\n        for (let j=0; j<9; j++) {\r\n            //give squares naming convention `${row}${col}`\r\n            let row = (Math.floor(i/3)*3 + 1) + Math.floor(j/3);\r\n            let col = ((i % 3) * 3) + 1 + (j % 3);\r\n            let square = String(row)+String(col);\r\n            squares.push(<Square \r\n                row={row} col={col} \r\n                key={square} square={square}/>)\r\n        }\r\n        return (\r\n          <td className=\"box\">\r\n            {squares}\r\n          </td>\r\n        )\r\n    }\r\n    \r\n    return (\r\n      <table className=\"board\">\r\n        <tbody>\r\n            <tr>\r\n                <Box box={1} />\r\n                <Box box={2} />\r\n                <Box box={3} />\r\n            </tr>\r\n            <tr>\r\n                <Box box={4} />\r\n                <Box box={5} />\r\n                <Box box={6} />\r\n            </tr>\r\n            <tr>\r\n                <Box box={7} />\r\n                <Box box={8} />\r\n                <Box box={9} />\r\n            </tr>\r\n        </tbody>\r\n      </table>\r\n    );\r\n}","import React, { useState } from 'react';\r\nimport {useSelector, useDispatch } from 'react-redux'\r\nimport { getSolution, getSortSolution } from './features/square/helper';\r\nimport './App.css';\r\nimport { setSolution, resetPuzzle } from './features/square/squareSlice';\r\nimport { Board } from './components/Board';\r\n\r\n\r\nfunction App() {\r\n  let dispatch = useDispatch();\r\n  let isSolvable = useSelector(state => state.square.isSolvable);\r\n  const [isSolved, setSolved] = useState(false);\r\n  \r\n  const squares = useSelector(state=> state.square.board);\r\n  \r\n  const solve = e => {\r\n    let solvedPuzzle = getSolution(squares);\r\n    dispatch(setSolution(solvedPuzzle));\r\n    setSolved(true);\r\n  }\r\n  \r\n  const sortSolve = e => {\r\n    let result = getSortSolution(squares);\r\n    if (!result) {\r\n      // console.log('unsolvable');\r\n    } else {\r\n      dispatch(setSolution(result));\r\n      setSolved(true);\r\n    }\r\n  }\r\n\r\n  const reset = e => {\r\n    setSolved(false);\r\n    dispatch(resetPuzzle());\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        React Sudoku\r\n      </header>\r\n        <Board/>\r\n        {!isSolved ? \r\n        <>\r\n        {/* <button onClick={solve} disabled={!isSolvable}>{isSolvable ? 'Solve!' : 'No Solution!'}</button>  */}\r\n        <button onClick={sortSolve} disabled={!isSolvable}>{isSolvable ? 'Solve!' : 'No Solution!'}</button>\r\n        </>\r\n        :\r\n        <button onClick={reset}>Reset</button>\r\n        }\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { createSlice } from '@reduxjs/toolkit';\r\n\r\nexport const counterSlice = createSlice({\r\n  name: 'counter',\r\n  initialState: {\r\n    value: 0,\r\n  },\r\n  reducers: {\r\n    increment: state => {\r\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\r\n      // doesn't actually mutate the state because it uses the Immer library,\r\n      // which detects changes to a \"draft state\" and produces a brand new\r\n      // immutable state based off those changes\r\n      state.value += 1;\r\n    },\r\n    decrement: state => {\r\n      state.value -= 1;\r\n    },\r\n    incrementByAmount: (state, action) => {\r\n      state.value += action.payload;\r\n    },\r\n  },\r\n});\r\n\r\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\r\n\r\n// The function below is called a thunk and allows us to perform async logic. It\r\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\r\n// will call the thunk with the `dispatch` function as the first argument. Async\r\n// code can then be executed and other actions can be dispatched\r\nexport const incrementAsync = amount => dispatch => {\r\n  setTimeout(() => {\r\n    dispatch(incrementByAmount(amount));\r\n  }, 1000);\r\n};\r\n\r\n// The function below is called a selector and allows us to select a value from\r\n// the state. Selectors can also be defined inline where they're used instead of\r\n// in the slice file. For example: `useSelector((state) => state.counter.value)`\r\nexport const selectCount = state => state.counter.value;\r\n\r\nexport default counterSlice.reducer;\r\n","import { configureStore } from '@reduxjs/toolkit';\r\nimport counterReducer from '../features/counter/counterSlice';\r\nimport squareReducer from '../features/square/squareSlice';\r\n\r\nexport default configureStore({\r\n  reducer: {\r\n    counter: counterReducer,\r\n    square: squareReducer\r\n  },\r\n});\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport store from './app/store';\r\nimport { Provider } from 'react-redux';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}